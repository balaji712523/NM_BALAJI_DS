# -*- coding: utf-8 -*-
"""nmproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x1ZIAnUC0aGy25Ef_J_0p_1FEevVNY0J
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import pandas as pd

try:
    df_movies = pd.read_csv('movies.csv')
    display(df_movies.head())
except FileNotFoundError:
    print("Error: 'movies.csv' not found. Please ensure the file exists in the current directory.")
    df_movies = None # Assign None to indicate failure
except pd.errors.EmptyDataError:
    print("Error: 'movies.csv' is empty.")
    df_movies = None
except pd.errors.ParserError:
    print("Error: Unable to parse 'movies.csv'. Please check the file format.")
    df_movies = None
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    df_movies = None

"""# Task
Tell me about this dataset.

Here is all the data you need:
"ratings.xlsx"

## Data loading

### Subtask:
Load the data from "ratings.xlsx" into a pandas DataFrame.

**Reasoning**:
Load the data from "ratings.xlsx" into a pandas DataFrame and display the first few rows.
"""

import pandas as pd

try:
    df = pd.read_excel('ratings.xlsx')
    display(df.head())
except FileNotFoundError:
    print("Error: 'ratings.xlsx' not found.")
    df = None
except Exception as e:
    print(f"An error occurred: {e}")
    df = None

"""## Data exploration

### Subtask:
Explore the loaded data to understand its characteristics.

**Reasoning**:
I need to explore the data's characteristics as instructed, including shape, data types, missing values, descriptive statistics, and distributions for numerical and categorical features.  I will also check for duplicates.
"""

# Check the shape of the DataFrame
print("Shape of the DataFrame:", df.shape)

# Examine data types
print("\nData types of each column:\n", df.dtypes)

# Identify missing values
print("\nNumber of missing values in each column:\n", df.isnull().sum())

# Descriptive statistics for numerical columns
print("\nDescriptive statistics for numerical columns:\n", df.describe())

# Explore distributions of numerical columns
# Since we have rating (numerical) we can use a histogram
import matplotlib.pyplot as plt
plt.figure(figsize=(8, 6))
plt.hist(df['rating'], bins=10, edgecolor='black')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.title('Distribution of Movie Ratings')
plt.show()


# Explore categorical columns (if any).  userId and movieId are likely categorical.
print("\nUnique User IDs:", df['userId'].nunique())
print("\nUnique Movie IDs:", df['movieId'].nunique())

plt.figure(figsize=(8, 6))
df['userId'].value_counts().head(20).plot(kind='bar')
plt.xlabel('User ID')
plt.ylabel('Frequency')
plt.title('Top 20 User IDs by Rating Count')
plt.show()


# Check for duplicate rows
print("\nNumber of duplicate rows:", df.duplicated().sum())

"""## Data analysis

### Subtask:
Calculate descriptive statistics and analyze the distribution of data.

**Reasoning**:
Calculate descriptive statistics for numerical columns and analyze the distribution of the 'rating' column.
"""

# Calculate descriptive statistics
numerical_cols = ['userId', 'movieId', 'rating', 'timestamp']
descriptive_stats = df[numerical_cols].describe()
display(descriptive_stats)

# Analyze the distribution of the 'rating' column
import matplotlib.pyplot as plt
plt.figure(figsize=(8, 6))
plt.hist(df['rating'], bins=20, edgecolor='black', color='skyblue')  # Increased bins for finer detail
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.title('Distribution of Movie Ratings')
plt.show()

# Analyze the distribution of categorical columns
print(f"Number of unique users: {df['userId'].nunique()}")
print(f"Number of unique movies: {df['movieId'].nunique()}")

# Frequency distribution of ratings for each user
user_rating_counts = df.groupby('userId')['rating'].count()
print("\nTop 10 users by number of ratings:\n", user_rating_counts.sort_values(ascending=False).head(10))

# Visualize top 10 users
plt.figure(figsize=(10, 6))
user_rating_counts.sort_values(ascending=False).head(10).plot(kind='bar', color='lightcoral')
plt.xlabel('User ID')
plt.ylabel('Number of Ratings')
plt.title('Top 10 Users by Number of Ratings')
plt.show()

# Frequency distribution of ratings for each movie
movie_rating_counts = df.groupby('movieId')['rating'].count()
print("\nTop 10 movies by number of ratings:\n", movie_rating_counts.sort_values(ascending=False).head(10))

# Visualize top 10 movies
plt.figure(figsize=(10, 6))
movie_rating_counts.sort_values(ascending=False).head(10).plot(kind='bar', color='lightgreen')
plt.xlabel('Movie ID')
plt.ylabel('Number of Ratings')
plt.title('Top 10 Movies by Number of Ratings')
plt.show()

"""**Reasoning**:
Investigate potential correlations between numerical columns, especially between 'timestamp' and 'rating'.


"""

import matplotlib.pyplot as plt
import pandas as pd

# Convert timestamp to datetime objects
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s')

# Extract relevant time features
df['year'] = df['timestamp'].dt.year
df['month'] = df['timestamp'].dt.month
df['dayofweek'] = df['timestamp'].dt.dayofweek  # Monday=0, Sunday=6

# Calculate correlations
correlation_matrix = df[['rating', 'year', 'month', 'dayofweek']].corr()
display(correlation_matrix)

# Visualize the relationship between rating and year
plt.figure(figsize=(10, 6))
plt.scatter(df['year'], df['rating'], alpha=0.1, color='purple')  # Use alpha for better visualization
plt.xlabel('Year')
plt.ylabel('Rating')
plt.title('Rating vs. Year')
plt.show()

# Visualize the relationship between rating and month
plt.figure(figsize=(10, 6))
plt.scatter(df['month'], df['rating'], alpha=0.1, color='orange')
plt.xlabel('Month')
plt.ylabel('Rating')
plt.title('Rating vs. Month')
plt.show()

# Visualize the relationship between rating and dayofweek
plt.figure(figsize=(10, 6))
plt.scatter(df['dayofweek'], df['rating'], alpha=0.1, color='green')
plt.xlabel('Day of Week')
plt.ylabel('Rating')
plt.title('Rating vs. Day of Week')
plt.show()

"""## Data visualization

### Subtask:
Visualize the data to gain insights into its distributions and relationships.

**Reasoning**:
Create histograms, box plots, scatter plot, and heatmap to visualize the data.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Histograms
plt.figure(figsize=(12, 8))
plt.subplot(2, 2, 1)
plt.hist(df['userId'], bins=30, edgecolor='black')
plt.xlabel('User ID')
plt.ylabel('Frequency')
plt.title('Distribution of User IDs')

plt.subplot(2, 2, 2)
plt.hist(df['movieId'], bins=30, edgecolor='black')
plt.xlabel('Movie ID')
plt.ylabel('Frequency')
plt.title('Distribution of Movie IDs')

plt.subplot(2, 2, 3)
plt.hist(df['rating'], bins=10, edgecolor='black')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.title('Distribution of Ratings')

plt.subplot(2, 2, 4)
plt.hist(df['timestamp'].dt.year, bins=len(df['timestamp'].dt.year.unique()), edgecolor='black')
plt.xlabel('Year')
plt.ylabel('Frequency')
plt.title('Distribution of Timestamps (Year)')

plt.tight_layout()
plt.show()


# Box plots
plt.figure(figsize=(12, 6))
plt.subplot(1, 3, 1)
sns.boxplot(y=df['userId'])
plt.title('Boxplot of User IDs')

plt.subplot(1, 3, 2)
sns.boxplot(y=df['movieId'])
plt.title('Boxplot of Movie IDs')

plt.subplot(1, 3, 3)
sns.boxplot(y=df['rating'])
plt.title('Boxplot of Ratings')

plt.tight_layout()
plt.show()


# Scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(df['userId'], df['rating'], c=df['movieId'], cmap='viridis', alpha=0.5)
plt.xlabel('User ID')
plt.ylabel('Rating')
plt.title('User ID vs. Rating (Colored by Movie ID)')
plt.colorbar(label='Movie ID')
plt.show()


# Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(df[['userId', 'movieId', 'rating', 'year', 'month', 'dayofweek']].corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Matrix Heatmap')
plt.show()

"""## Summary:

### Q&A
There were no explicit questions asked in the task. However, the analysis provides answers to implicit questions about the dataset's characteristics, distributions, and relationships between variables.  For example, the analysis reveals the number of unique users and movies, the distribution of ratings, and the correlation between ratings and time-based features.


### Data Analysis Key Findings
* The dataset contains 1,048,575 movie ratings from 7,045 unique users on 22,240 unique movies.
* The average movie rating is approximately 3.54.
* There are no missing values or duplicate rows in the dataset.
* The distribution of ratings shows a slight skew towards higher ratings.
* Some users have rated a significantly higher number of movies than others (power users).
* Some movies have received significantly more ratings than others.
* There's a weak correlation between rating and year, month, and day of week, as revealed by the correlation analysis and scatter plots.


### Insights or Next Steps
* Investigate the potential reasons behind the variations in the number of ratings per user and per movie.  Are certain users more active raters?  Are some movies more popular?
* Explore the weak correlations between rating and time features in more detail.  Are there specific time periods where rating patterns differ significantly?  Consider more granular time features (e.g., hour of day) for a deeper analysis.

"""